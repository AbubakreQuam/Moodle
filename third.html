<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Reentrancy Attack</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #f7f7f7;
  }
  .page {
    display: none;
    padding: 20px;
  }
  .question {
    margin-top: 10px;
  }
  /* Style for the section content */
    .section-content {
        margin: 20px;
        padding: 20px;
        border: 1px solid #ddd;
        background-color: #f5f5f5;
    }
    .section-content1 {
        margin: 20px;
        padding: 20px;
        border: 1px solid #ddd;
        background-color: #f5f5f5;
    }
  /* Style for the buttons */
.btn-container {
  display: flex;
  justify-content: space-between;
  margin-top: 20px;
}

.btn {
  cursor: pointer;
  padding: 10px 20px;
  background-color: #007bff;
  color: white;
  border: none;
  text-align: center;
  border-radius: 5px;
  width: 200px;
  height: 50px;
}
</style>
</head>
<body>

  <div class="page" id="page1">
    <!-- Section One Content -->
    <div class="section-content">
        <h2 style="margin-bottom: 50px; text-align: center;">MODULE 3: REENTRANCY ATTACK</h2>
  
        <h3>Definition and Explanation: </h3>
        <div class="section-content1">
          <p>Greetings learners! Module 3 is here to unravel the intricacies of the Reentrancy Attack. This type of attack exploits the asynchronous nature of smart contracts, allowing attackers to repeatedly reenter the same function before the previous invocations complete. </p>
          <p>Let's break it down. In a typical scenario, a smart contract function should execute to completion before another instance of the same function begins. However, in a reentrancy attack, the attacker can exploit certain conditions to interrupt the normal flow, enabling multiple reentries into the function. </p>
        </div>


        <h3>Real-world Examples: </h3>
        <div class="section-content1">
          <p>Understanding real-world examples will provide context to this vulnerability: </p>
          <p>1.	The DAO Attack (2016): The infamous DAO attack involved a reentrancy exploit. The attacker manipulated the smart contract to repeatedly withdraw funds before the system could update the user's balance. </p>
          <p>2.	The King of Ether Attack (2016): Another case where an attacker used a reentrancy attack to drain funds from a vulnerable contract, highlighting the pervasive nature of this vulnerability. </p>
        </div>

        <h3>Impact and Potential Consequences: </h3>
        <div class="section-content1">
          <p>Now, let's explore the impact and consequences of a Reentrancy Attack: </p>
          <p>•	Financial Losses: Attackers can drain funds from a contract, leading to substantial financial losses. </p>
          <p>•	Disruption of Functionality: The normal functioning of the smart contract can be disrupted, affecting its intended purpose. </p>
          <p>•	Erosion of Trust: Users may lose trust in the security and reliability of smart contracts, impacting the broader blockchain ecosystem. </p>
        </div>

        <h3>Mitigation Strategies: </h3>
        <div class="section-content1">
          <p>Understanding how to mitigate the risks associated with Reentrancy Attacks is crucial: </p>
          <p>1.	Use of Checks-Effects-Interactions Pattern: Design smart contracts following the Checks-Effects-Interactions pattern to minimize vulnerabilities. </p>
          <p>2.	Limitations on External Calls: Implement restrictions on external calls within smart contracts to prevent reentrancy. </p>
          <p>3.	Gas Limit Considerations: Set appropriate gas limits to avoid out-of-gas attacks, which can be coupled with reentrancy. </p>
        </div>        
      </div>
  </div>

  


  

  <script>
    let currentPage = 1;

    function showPage(pageId) {
      document.getElementById(`page${currentPage}`).style.display = 'none';
      document.getElementById(pageId).style.display = 'block';
      currentPage = parseInt(pageId.replace('page', ''));
    }

    // Start by showing the first page
    showPage('page1');

    document.getElementById("next-button").addEventListener("click", function() {
            window.location.href = "index.html";
        });
      
    document.getElementById("quiz-button").addEventListener("click", function() {
        window.location.href = "questions.html";
    });
  </script>
</body>
</html>
